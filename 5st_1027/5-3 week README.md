## 모듈 시스템과 이벤트 루프

## Node.js 모듈 시스템: 레고 블록으로 프로그램 만들기

### 기본 개념

1. **모듈**: 각각의 레고 블록
   - 특정 기능을 가진 코드의 묶음입니다.
   - 독립적으로 존재하며, 다른 블록과 조합할 수 있습니다.

2. **require 함수**: 레고 블록 가져오기
   - 다른 모듈(레고 블록)을 현재 파일에 가져옵니다.
   - `const myBlock = require('./myBlock');`

3. **module.exports**: 레고 블록의 연결 부분 만들기
   - 모듈에서 외부로 공개할 부분을 정의합니다.
   - 다른 파일에서 이 모듈을 사용할 때 접근할 수 있는 부분입니다.

### 작동 방식

1. **모듈 만들기 (레고 블록 제작)**
   ```javascript
   // greetingBlock.js
   function sayHello(name) {
     console.log(`안녕하세요, ${name}님!`);
   }

   module.exports = sayHello;
   ```
   - 이것은 "인사하기" 기능을 가진 레고 블록을 만든 것과 같습니다.

2. **모듈 사용하기 (레고 블록 조립)**
   ```javascript
   // main.js
   const greet = require('./greetingBlock'); -> require 함수를 이용 greetingBlock.js 불러옵니다.

   greet('철수'); // "안녕하세요, 철수님!" 출력
   ```
   - 만든 레고 블록을 가져와서 사용하는 것과 같습니다.

### 모듈의 장점

1. **코드 재사용**: 한 번 만든 레고 블록을 여러 곳에서 사용할 수 있습니다.
2. **코드 구조화**: 큰 프로그램을 작은 부품들로 나눠 관리할 수 있습니다.
3. **네임스페이스 관리**: 각 모듈은 독립적인 공간을 가져 이름 충돌을 방지합니다.

### 다양한 모듈 내보내기 방식

1. **단일 기능 내보내기**
   ```javascript
   module.exports = function() { /* ... */ };
   ```  
이 방식은 모듈에서 하나의 함수나 객체만을 내보낼 때 사용합니다. 모듈을 불러오면 이 단일 기능을 직접 사용할 수 있습니다.  

2. **여러 기능 내보내기**
   ```javascript
   module.exports = {
     function1: function() { /* ... */ },
     function2: function() { /* ... */ }
   };
   ```  
이 방식은 여러 기능을 하나의 객체로 묶어 내보낼 때 사용합니다. 모듈을 불러오면 객체의 속성으로 각 기능에 접근할 수 있습니다.  


3. **객체에 속성 추가하기**
   ```javascript
   exports.function1 = function() { /* ... */ };
   exports.function2 = function() { /* ... */ };
   ```  
이 방식은 exports 객체에 직접 속성을 추가하는 방식입니다.  
module.exports와 exports는 처음에 같은 객체를 참조하지만, module.exports에 새 객체를 할당하면 연결이 끊어집니다.  
4. **모듈 불러오기**  
```
const myModule = require('./myModule');  
```
여기서 ./myModule은 현재 디렉토리에 있는 myModule.js 파일을 가리킵니다.  

Node.js의 모듈 시스템을 사용하면, 큰 프로그램을 작은 부품(모듈)들로 나누어 개발할 수 있습니다. 이는 마치 다양한 레고 블록들을 조합하여 복잡한 구조물을 만드는 것과 같습니다. 각 모듈은 독립적으로 개발, 테스트, 재사용될 수 있어 효율적인 프로그램 개발이 가능합니다.

### 이벤트 루프


## Node.js의 이벤트 루프: 비동기 작업의 관리자

Node.js의 이벤트 루프는 비동기 작업을 효율적으로 관리하는 시스템입니다. 이를 놀이공원의 여러 놀이기구를 관리하는 것에 비유해 설명해 보겠습니다.

### 1. 타이머 단계 (Timers)
- **비유**: 시간제 놀이기구
- **역할**: `setTimeout`과 `setInterval`로 예약된 콜백을 실행합니다.
- **작동**: 정해진 시간이 되면 해당 콜백을 실행합니다.
- **예시**: "30분 후에 알림 울리기"와 같은 작업

### 2. 보류 중인 콜백 단계 (Pending Callbacks)
- **비유**: 대기 중인 손님들
- **역할**: 이전 루프에서 연기된 I/O 콜백을 실행합니다.
- **작동**: 시스템 작업(예: TCP 오류 처리)과 관련된 콜백을 처리합니다.
- **예시**: 네트워크 오류 처리와 같은 작업

### 3. 유휴, 준비 단계 (Idle, Prepare)
- **비유**: 놀이공원 내부 정비
- **역할**: Node.js 내부에서만 사용됩니다.
- **작동**: 이벤트 루프의 다음 반복을 준비합니다.

### 4. 폴링 단계 (Poll)
- **비유**: 새로운 손님 맞이하기
- **역할**: 새로운 I/O 이벤트를 처리하고 관련 콜백을 실행합니다.
- **작동**: 
  1. 타이머가 만료되었는지 확인합니다.
  2. 보류 중인 I/O 콜백을 실행합니다.
  3. 필요하다면 잠시 대기하며 새 이벤트를 기다립니다.
- **예시**: 파일 읽기/쓰기, 네트워크 요청 처리

### 5. 체크 단계 (Check)
- **비유**: 빠른 패스트트랙
- **역할**: `setImmediate()` 콜백을 실행합니다.
- **작동**: 폴링 단계 직후에 실행되어야 할 콜백을 처리합니다.
- **예시**: 긴급하게 처리해야 할 작업

### 6. 종료 콜백 단계 (Close Callbacks)
- **비유**: 놀이기구 정리 및 마감
- **역할**: 일부 종료 콜백을 실행합니다.
- **작동**: 소켓이나 핸들을 닫는 등의 정리 작업을 수행합니다.
- **예시**: 서버 연결 종료, 파일 스트림 닫기

### 이벤트 루프의 전체 흐름

1. 이벤트 루프는 위의 단계들을 순차적으로 반복합니다.
2. 각 단계에는 실행할 콜백의 FIFO(First-In-First-Out) 큐가 있습니다.
3. 한 단계가 시작되면, 해당 단계의 작업을 모두 처리하거나 시스템 한도에 도달할 때까지 실행합니다.
4. 그 후 다음 단계로 이동합니다.

이 구조를 통해 Node.js는 단일 스레드로 동작하면서도 많은 비동기 작업을 효율적으로 처리할 수 있습니다. 각 단계는 특정 유형의 작업을 담당하며, 이를 통해 I/O 작업, 타이머, 즉시 실행해야 할 작업 등을 균형있게 처리할 수 있습니다.

